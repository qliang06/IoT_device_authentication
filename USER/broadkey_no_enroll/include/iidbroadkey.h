/*! \copyright Copyright 2018 Intrinsic ID B.V. All rights reserved.\n
    This text contains proprietary, confidential information of Intrinsic ID B.V.,
    and may be used, copied, distributed and/or published only pursuant to the
    terms of a valid license agreement with Intrinsic ID B.V.\n
    This copyright notice must be retained as part of this text at all times.
*/
#ifndef __IID_BROADKEY__H__
#define __IID_BROADKEY__H__

#include "iid_platform.h"

#ifdef __cplusplus
extern "C"
{
#endif

/************************************************************************
*                        D E F I N I T I O N S                          *
*************************************************************************/
#define BK_CONFIGURATION_PRO_ENABLED

#define BK_SECURITY_SIZE_BITS               (256)

#define BK_SRAM_PUF_SIZE_BYTES              (1024)

#define BK_AC_SIZE_BYTES                    (968)

#define BK_KEY_CODE_HEADER_SIZE_BYTES (44)

#define BK_ECC_CRYPTOGRAM_HEADER_SIZE_BYTES (80)

#define BK_ECC_MAX_CURVE_SIZE_BYTES         (32)            /* corresponds to 256 bit curve */

#define BK_ECC_KEY_CODE_HEADER_SIZE_BYTES   (48)

#define BK_ECC_PRIVATE_KEY_CODE_SIZE_BYTES  (BK_ECC_KEY_CODE_HEADER_SIZE_BYTES + BK_ECC_MAX_CURVE_SIZE_BYTES)
#define BK_ECC_PUBLIC_KEY_CODE_SIZE_BYTES   (BK_ECC_KEY_CODE_HEADER_SIZE_BYTES + (2 * BK_ECC_MAX_CURVE_SIZE_BYTES))


/*! \brief Defines the key types which can be generated by the \ref bk_get_key function.
 */
typedef enum bk_sym_key_type
{
    BK_SYM_KEY_TYPE_128 = 0x00,
    BK_SYM_KEY_TYPE_192 = 0x01,
    BK_SYM_KEY_TYPE_256 = 0x02
} bk_sym_key_type_t;


/*! \brief Defines the named elliptic curves which can be recognized by the
 *         elliptic curve functions.
 */
typedef enum bk_ecc_curve
{
    /* The elliptic-curve cryptosystem specified by the NIST-P192/secp192r1 domain
     * parameters.
     */
    BK_ECC_CURVE_NIST_P192 = 0x00,

    /* The elliptic-curve cryptosystem specified by the NIST-P224/secp224r1 domain
     * parameters.
     */
    BK_ECC_CURVE_NIST_P224 = 0x01,

    /* The elliptic-curve cryptosystem specified by the NIST-P256/secp256r1 domain
     * parameters.
     */
    BK_ECC_CURVE_NIST_P256 = 0x02
} bk_ecc_curve_t;


/*! \brief Defines the allowed sources from which an elliptic curve private key
 *         can be generated using the elliptic curve functions.
 */
typedef enum bk_ecc_key_source
{
    /* The private key is derived in a direct line from the SRAM PUF's device unique
     * start-up data. Private keys derived in this way can always be exactly rederived
     * by calling elliptic curve functions with the same arguments in the same
     * cryptographic context, and on the same device.
     */
    BK_ECC_KEY_SOURCE_PUF_DERIVED = 0x00,

    /* The private key is randomly generated using BroadKey's internal cryptographically
     * secure random number generator which is seeded by entropy coming from the
     * device noise. Private keys generated in this way cannot be rederived by
     * elliptic curve functions.
     */
    BK_ECC_KEY_SOURCE_RANDOM = 0x01,

    /* The private key is an external value which is provided by the calling
     * application to the \ref bk_create_private_key function.
     */
    BK_ECC_KEY_SOURCE_USER_PROVIDED = 0x02
} bk_ecc_key_source_t;

/*! \brief Defines the allowed purposes which can be assigned to an elliptic curve
 *         private or public key. It is stored alongside the key in the corresponding
 *         key code.
 */
typedef enum bk_ecc_key_purpose
{
    /* Key (code)s marked with this purpose flag can be used for elliptic curve
     * key agreement and en/decryption functions.
     */
    BK_ECC_KEY_PURPOSE_ECDH = 0x01,

    /* Key (code)s marked with this purpose flag can be used for elliptic curve
     * signature generation and verification functions.
     */
    BK_ECC_KEY_PURPOSE_ECDSA = 0x02,

    /* This is the combination of the ECDH and ECDSA flags. Key (code)s marked
     * with this purpose flag can be used for everything allowed by the ECDH and
     * the ECDSA flags.
     */
    BK_ECC_KEY_PURPOSE_ECDH_AND_ECDSA = (BK_ECC_KEY_PURPOSE_ECDH | BK_ECC_KEY_PURPOSE_ECDSA)
} bk_ecc_key_purpose_t;

/*! \brief Defines the cryptogram type to be used in the \ref bk_generate_cryptogram
 *         function, and correspondingly the cryptogram type which was received
 *         by the \ref bk_process_cryptogram function.
 */
typedef enum bk_ecc_cryptogram_type
{
    /* Cryptogram type using static elliptic curve key pairs on both sending and
     * receiving side. All the basic security properties (confidentiality, integrity,
     * source authentication, non-replay able), but no forward secrecy and no
     * non-repudiation.
     * This cryptogram type achieves the highest performance, both in sending and
     * receiving.
     */
    BK_ECC_CRYPTOGRAM_TYPE_ECDH_STATIC = 0x00,

    /* Cryptogram type using an ephemeral key pair on the sending side, and a
     * static key pair on the receiving side. All the basic security properties
     * as above, and in addition forward secrecy w.r.t. loss of the sender's private
     * key. Still no non-repudiation.
     * The performance of this cryptogram type is lower than BK_ECC_CRYPTOGRAM_TYPE_ECDH_STATIC
     * for both sending and receiving.
     */
    BK_ECC_CRYPTOGRAM_TYPE_ECDH_EPHEMERAL = 0x01
} bk_ecc_cryptogram_type_t;

/*! \brief Defines the private key code type.
 */
typedef uint8_t bk_ecc_private_key_code_t[BK_ECC_PRIVATE_KEY_CODE_SIZE_BYTES];

/*! \brief Defines the public key code type.
 */
typedef uint8_t bk_ecc_public_key_code_t[BK_ECC_PUBLIC_KEY_CODE_SIZE_BYTES];


/****************************************************************************
*                      P U B L I C  I N T E R F A C E                       *
*****************************************************************************/
/*! \brief Get product information.
 *
 *  \details This function can be used to get the exact name, version and patch
 *           of this software module.
 *
 *  \param[out] *product_id Pointer to a byte buffer that will hold the product identifier.
 *
 *  \param[out] *major_version Pointer to a byte buffer that will hold the major software version.
 *
 *  \param[out] *minor_version Pointer to a byte buffer that will hold the minor software version.
 *
 *  \param[out] *patch Pointer to a byte buffer that will hold the software patch.
 *
 *  \param[out] *build_number Pointer to a byte buffer that will hold the build number.
 *
 *  \returns \ref IID_SUCCESS if success, otherwise another return code.
 */
iid_return_t bk_get_product_info(uint8_t * const product_id,
                                 uint8_t * const major_version,
                                 uint8_t * const minor_version,
                                 uint8_t * const patch,
                                 uint8_t * const build_number);

/*! \brief Initalizes BroadKey module.
 *
 *  \details This function is used to initialize the BroadKey software module before
 *           use, after each device power-up or reset.
 *
 *  \param[in,out] *sram_puf Pointer to physical SRAM that will be used
 *                           by BroadKey as PUF memory.
 *                           Its address must be aligned to 32 bits.
 *
 *  \param[in] sram_puf_size The size in bytes of available SRAM PUF that can
 *                           be used by the software.
 *                           The size of the SRAM must be at least \ref BK_SRAM_PUF_SIZE_BYTES
 *                           bytes.
 *
 *  \returns \ref IID_SUCCESS if success, otherwise another return code.
 */
iid_return_t bk_init(uint8_t * const sram_puf,
                     const uint16_t  sram_puf_size);


/*! \brief Re-instantiate a cryptographic context.
 *
 *  \details This function is used to re-instantiate a cryptographic context of
 *           BroadKey based on a provided activation code which was earlier generated
 *           by \ref bk_enroll. It is the responsibility of the calling software
 *           to reliably store an activation code after \ref bk_enroll, and retrieve
 *           it before \ref bk_start. Once a cryptographic context is instantiated,
 *           BroadKey's cryptographic functionality becomes available.
 *
 *  \param[in] *activation_code Pointer to a buffer that holds the retrieved activation
 *                              code, previously generated by \ref bk_enroll.
 *                              The size of the buffer must be at least \ref BK_AC_SIZE_BYTES
 *                              bytes.
 *                              Its address must be aligned to 32 bits.
 *
 *  \returns \ref IID_SUCCESS.
 */
iid_return_t bk_start(const uint8_t * const activation_code);

/*! \brief Un-instantiate a cryptographic context.
 *
 *  \details This function will un-instantiate a cryptographic context of BroadKey
 *           which was earlier instantiated by \ref bk_enroll or \ref bk_start.
 *           Once a cryptographic context is un-instantiated, BroadKey's cryptographic
 *           functionality becomes unavailable. Moreover, \ref bk_stop also ensures
 *           that all internal secrets related to the cryptographic context are
 *           effectively deleted (zeroized), which can be used as an additional
 *           security measure against attacks.
 *
 *  \returns \ref IID_SUCCESS if success, otherwise another return code.
 */
iid_return_t bk_stop(void);
/*! \brief (Re)generate a symmetric device key.
 *
 *  \details This function (re)generates a symmetric device key for the cryptographic
 *           context which was earlier instantiated by \ref bk_enroll or re-instantiated
 *           by \ref bk_start. The length of the generated key depends on the specified
 *           key type. For each key type, \ref bk_get_key can (re)generate up to 256
 *           independent device key values, controlled by the key \ref index input
 *           parameter. A call to \ref bk_get_key with the same input parameter values,
 *           key_type and index, on the same device instantiated with the same cryptographic
 *           context, will always return the same key value.
 *
 *  \param[in] key_type The type of the device key that will be generated.
 *                      This must be a value of the enumeration type \ref bk_sym_key_type_t.
 *
 *  \param[in] index An integer value in the range [0:255] indicating the index
 *                   of the device key that will be generated for the specified
 *                   key type. For each index value, a key is generated which is
 *                   completely independent from keys generated by other key index
 *                   values.
 *
 *  \param[out] *key Pointer to a buffer that whill hold the generated device key.
 *                   The size of the \ref key output buffer must be at least
 *                   long enough to hold the generated key type, as specified
 *                   by the \ref key_type input parameter.
 *
 *  \returns \ref IID_SUCCESS if success, otherwise another return code.
 */
iid_return_t bk_get_key(const bk_sym_key_type_t key_type,
                        const uint8_t           index,
                        uint8_t * const         key);


/*! \brief Generate a sequence of random bytes.
 *
 *  \details This function will generate a sequence of random bytes using a
 *           cryptographically secure random number generator which is seeded
 *           with unpredictable noise entropy from the device.
 *           This function can be called after enrollment or start.
 *
 *  \param[in] number_of_bytes Positive integer in the range [1:65535] which
 *                             specifies the number of random bytes that will be
 *                             returned.
 *                             The size in bytes of the allocated output buffer
 *                             pointed to by \ref data_buffer must be at least
 *                             equal to this value.
 *
 *  \param[out] *data_buffer Pointer to a buffer that will hold the requested
 *                           random bytes.
 *                           The size of this output buffer must be at least
 *                           \ref number_of_bytes.
 *
 *  \returns \ref IID_SUCCESS if success, otherwise another return code.
 */
iid_return_t bk_generate_random(const uint16_t  number_of_bytes,
                                uint8_t * const data_buffer);

/*! \brief (Re)generate an elliptic curve private key.
 *
 *  \details This function (re)generates an elliptic curve private key.
 *           It can (re)generate private keys from two possible sources:
 *             - device's secret fingerprint;
 *             - random number generator;
 *           The (optional) usage context influences the key derivation from
 *           aforementioned sources.
 *
 *  \param[in] curve Specifies the named elliptic curve on which the considered
 *                   private key is defined. It must be a valid curve type of the
 *                   \ref bk_ecc_curve_t enumeration.
 *
 *  \param[in] *usage_context Pointer to a buffer that holds an (optional) usage
 *                            context. When used, the entropy of this buffer is
 *                            included in the private key derivation for private
 *                            keys derived from the device fingerprint
 *                            (\ref key_source = \ref BK_ECC_KEY_SOURCE_PUF_DERIVED)
 *                            or from the device's random number generator
 *                            (\ref key_source = \ref BK_ECC_KEY_SOURCE_RANDOM).
 *                            The size of the buffer must be at least \ref usage_context_length
 *                            bytes.
 *                            Note: providing a usage context is optional. If the
 *                            specified \ref usage_context_length is 0, no usage
 *                            context is taken into account.
 *
 *  \param[in] usage_context_length The length in bytes of the \ref usage_context
 *                                  buffer. If this length is set to 0, no usage
 *                                  context is taken into account.
 *
 *  \param[in] key_source Specifies the source of the elliptic curve private key.
 *                        It must be a valid source of the \ref bk_ecc_key_source_t
 *                        enumeration:
 *                         - BK_ECC_KEY_SOURCE_PUF_DERIVED: the private key is derived
 *                           from the device fingerprint and (optionally) the provided
 *                           usage context;
 *                         - BK_ECC_KEY_SOURCE_RANDOM: the private key is uniformly
 *                           randomly generated from BroadKey's internal random number
 *                           generator and (optionally) the provided usage context;
 *                        Note: for \ref BK_ECC_KEY_SOURCE_PUF_DERIVED and
 *                        \ref BK_ECC_KEY_SOURCE_RANDOM, the \ref usage_context
 *                        entropy, if present, is added to the key derivation
 *                        process to provide a secure fallback or key diversification.
 *                        Note: (\ref key_source = \ref BK_ECC_KEY_SOURCE_USER_PROVIDED)
 *                        is NOT a valid input for this function.
 *
 *  \param[out] *private_key Pointer to a private key code buffer that holds the
 *                          generated elliptical private key.
 *                          Its address must be aligned to 32 bits.
 *                          The expected output is binary in network byte order
 *                          representation.
 *                          The size in bytes is determined by the specified curve.
 *
 *  \returns \ref IID_SUCCESS if successful, otherwise another return code.
 */
iid_return_t bk_get_private_key(const bk_ecc_curve_t      curve,
                                const uint8_t * const     usage_context,
                                const uint32_t            usage_context_length,
                                const bk_ecc_key_source_t key_source,
                                uint8_t * const           private_key);

/*! \brief Wrap a user-provided key into a key code.
 *
 *  \details This function securely wraps (authenticated encrypts) a user-provided
 *           key into a key code. In addition to a variable-length key, the user
 *           can provide an index value which gets wrapped alongside the key.
 *           The user can assign a custom meaning to this index which relates to
 *           the context of the key. When the key code is unwrapped again with
 *           \ref bk_unwrap, the index will also be returned.
 *
 *  \param[in] index An integer value in the range [0:255] indicating the index
 *                   of the key-to-be-wrapped. For bk_wrap/unwrap, the index is
 *                   a user-defined value that gets wrapped (in \ref bk_wrap) and
 *                   unwrapped (in \ref bk_unwrap) alongside the actual key value.
 *                   The user of BroadKey can use it, e.g. to specify context-information
 *                   associated to the key.
 *
 *  \param[in] *key Pointer to a buffer that holds the plain key-to-be-wrapped.
 *                  Its address must be aligned to 32 bits.
 *                  The length of the buffer must be equal to \ref key_length bytes.
 *
 *  \param[in] key_length The length in bytes of the key-to-be-wrapped. This must
 *                        be an integer value in the range [4:4:1024], i.e. the
 *                        smallest allowed value is 4, the largest is 1024, and
 *                        only values that are a multiple of 4 are allowed.
 *
 *  \param[out] *key_code Pointer to a buffer that will hold the generated key code.
 *                        Its address must be aligned to 32 bits.
 *                        The size of the \ref key_code buffer must be at
 *                        least equal to the length of the provided key
 *                        incremented with the constant size of the key code header
 *                        (\ref BK_KEY_CODE_HEADER_SIZE_BYTES).
 *
 *  \returns \ref IID_SUCCESS if success, otherwise another return code.
 */
iid_return_t bk_wrap(const uint8_t         index,
                     const uint8_t * const key,
                     const uint16_t        key_length,
                     uint8_t * const       key_code);

/*! \brief Unwrap a key code into a key.
 *
 *  \details This function will successfully unwrap (decrypt and authenticate) a
 *           provided key code, given that it is called on the same device and in
 *           the same cryptographic context that was used to produce the key code
 *           with \ref bk_wrap. In addition to the originally wrapped key, \ref bk_unwrap
 *           will also return the index value that got wrapped alongside the key.
 *           The user can parse this index value to determine the context of the key.
 *
 *  \param[in] *key_code Pointer to a buffer that holds the retrieved key code.
 *                       Its address must be aligned to 32 bits.
 *                       The size of the buffer must be sufficient to contain the
 *                       full key code as was produced by a call to \ref bk_wrap.
 *
 *  \param[out] *key Pointer to a buffer that will hold the unwrapped key.
 *                   Its address must be aligned to 32 bits.
 *                   The size of the buffer can be calculated by subtracting
 *                   \ref BK_KEY_CODE_HEADER_SIZE_BYTES from the size of \ref key_code.
 *
 *  \param[out] *key_length Pointer to a byte buffer which will contain the size
 *                          in bytes of \ref key.
 *                          Its value will be in the [4, 1024] range and a multiple of 4.
 *
 *  \param[out] *index Pointer to a byte buffer that will hold the index
 *                     associated to the unwrapped \ref key.
 *
 *  \returns \ref IID_SUCCESS if success, otherwise another return code.
 */
iid_return_t bk_unwrap(const uint8_t * const key_code,
                       uint8_t * const       key,
                       uint16_t * const      key_length,
                       uint8_t * const       index);

/*! \brief Derive an elliptic curve public key from a private key.
 *
 *  \details This function derives the elliptic curve public key corresponding
 *           to a private key created with \ref bk_get_private_key, and
 *           outputs the public key.
 *
 *  \param[in] use_point_compression This flag is present for future use compatibility,
 *                                   but is not used for this product version of BroadKey.
 *                                   For this product version, this value has to
 *                                   be set to False (no point compression). Any
 *                                   other values will result in the return code
 *                                   \ref IID_INVALID_PARAMETERS.
 *
 *  \param[in] curve Specifies the named elliptic curve on which the private key is defined.
 *                   It must be a valid curve type of the \ref bk_ecc_curve_t enumeration.
 *
 *  \param[in] *private_key Pointer to a private key buffer that holds the elliptic curve
 *                          private key created by \ref bk_get_private_key.
 *                          Its address must be aligned to 32 bits.
 *
 *  \param[out] *public_key Pointer to a buffer that will hold the exported public key.
 *                          The output is in X9.62 binary format.
 *                          The size in bytes is determined by the used curve.
 *
 *  \returns \ref IID_SUCCESS if successful, otherwise another return code.
 */
iid_return_t bk_derive_public_key(const bool            use_point_compression,
                                  const bk_ecc_curve_t  curve,
                                  const uint8_t * const private_key,
                                  uint8_t * const       public_key);

/*! \brief Securely protect an elliptic curve private key into a private key code.
 *
 *  \details This function transforms an elliptic curve private key into a protected
 *           private key code which is only usable within the same cryptographic context,
 *           and on the same unique device, it was created on.
 *           This function can take private keys from three possible sources:
 *            - private keys derived from the device's secret fingerprint;
 *            - randomly generated private keys;
 *            - user-provided private keys.
 *           Alongside the private key values, this function also stores the curve
 *           and key purpose flags in the private key code format. This makes the
 *           future use of a generated private key code self-contained, i.e. a
 *           consuming function knows on which curve the contained private key is
 *           defined, and for which purposes it is allowed to be used.
 *           Note: the protection mechanisms for transforming private keys into
 *           private key codes are similar as for the \ref bk_wrap function, but
 *           private key codes cannot be unwrapped by \ref bk_unwrap. The underlying
 *           internal keys used by \ref bk_create_private_key for protecting private
 *           key codes are also different as for key codes generated by \ref bk_wrap.
 *           Once packed into a private key code, the actual private key values
 *           can no longer be publicly retrieved by BroadKey.
 *
 *  \param[in] curve Specifies the named elliptic curve on which the considered
 *                   private key is defined. It must be a valid curve type of the
 *                   \ref bk_ecc_curve_t enumeration.
 *
 *  \param[in] purpose_flags Flag which specifies the usage purpose of the private
 *                           key. It must be a valid flag of the \ref bk_ecc_key_purpose_t
 *                           enumeration.
 *
 *  \param[in] *usage_context Pointer to a buffer that holds an (optional) usage
 *                            context. When used, the entropy of this buffer is
 *                            included in the private key derivation for private
 *                            keys derived from the device fingerprint
 *                            (\ref key_source = \ref BK_ECC_KEY_SOURCE_PUF_DERIVED)
 *                            or from the device's random number generator
 *                            (\ref key_source = \ref BK_ECC_KEY_SOURCE_RANDOM).
 *                            The size of the buffer must be at least \ref usage_context_length
 *                            bytes.
 *                            Note: providing a usage context is optional. If the
 *                            specified \ref usage_context_length is 0, no usage
 *                            context is taken into account.
 *
 *  \param[in] usage_context_length The length in bytes of the \ref usage_context
 *                                  buffer. If this length is set to 0, no usage
 *                                  context is taken into account.
 *
 *  \param[in] key_source Specifies the source of the elliptic curve private key.
 *                        It must be a valid source of the \ref bk_ecc_key_source_t
 *                        enumeration:
 *                         - BK_ECC_KEY_SOURCE_PUF_DERIVED: the private key is derived
 *                           from the device fingerprint and (optionally) the provided
 *                           usage context;
 *                         - BK_ECC_KEY_SOURCE_RANDOM: the private key is uniformly
 *                           randomly generated from BroadKey's internal random number
 *                           generator and (optionally) the provided usage context;
 *                         - BK_ECC_KEY_SOURCE_USER_PROVIDED: the private key is
 *                           provided externally. When this key source is selected,
 *                           \ref usage_context is not used and \ref private_key
 *                           is used directly with only a check that it is a
 *                           well-formed private key for the specified curve.
 *                        The resulting private key will be wrapped by a device-unique
 *                        PUF key, hence the resulting private key code can only
 *                        be used within the same cryptographic context on the same
 *                        device.
 *                        Note: for \ref BK_ECC_KEY_SOURCE_PUF_DERIVED and
 *                        \ref BK_ECC_KEY_SOURCE_RANDOM, the \ref usage_context
 *                        entropy, if present, is added to the key derivation
 *                        process to provide a secure fallback or key diversification.
 *
 *  \param[in] *private_key Pointer to a private key code buffer that holds the
 *                          private key used when \ref key_source is \ref BK_ECC_KEY_SOURCE_USER_PROVIDED.
 *                          Its address must be aligned to 32 bits.
 *                          The expected input is binary in network byte order
 *                          representation.
 *                          The size in bytes is determined by the specified curve.
 *                          Note: for key sources other than \ref BK_ECC_KEY_SOURCE_USER_PROVIDED,
 *                          this input is not used.
 *
 *  \param[out] *private_key_code Pointer to a private key code buffer that will
 *                                hold the created elliptic curve private key code.
 *                                Its address must be aligned to 32 bits.
 *
 *  \returns \ref IID_SUCCESS if successful, otherwise another return code.
 */
iid_return_t bk_create_private_key(const bk_ecc_curve_t              curve,
                                   const bk_ecc_key_purpose_t        purpose_flags,
                                   const uint8_t * const             usage_context,
                                   const uint32_t                    usage_context_length,
                                   const bk_ecc_key_source_t         key_source,
                                   const uint8_t * const             private_key,
                                   bk_ecc_private_key_code_t * const private_key_code);

/*! \brief Compute an elliptic curve public key code from a private key code.
 *
 *  \details This function computes the elliptic curve public key corresponding
 *           to a private key code created with \ref bk_create_private_key, and
 *           outputs the public key in a corresponding public key code format.
 *           The curve and purpose flags of the public key (code) will be the same
 *           as the one of the provided private key (code).
 *           Note: the protection mechanisms for storing public keys as public key
 *           codes are similar as for the \ref bk_wrap function, but public key
 *           codes cannot be unwrapped by \ref bk_unwrap. The underlying internal
 *           keys used by \ref bk_compute_public_from_private_key for protecting
 *           public key codes are also different as for key codes generated by
 *           \ref bk_wrap. If needed, the function \ref bk_export_public_key can
 *           be used to retrieve the public key value contained in a public key code.
 *
 *  \param[in] *private_key_code Pointer to a private key code buffer that holds
 *                               the elliptic curve private key code created by
 *                               \ref bk_create_private_key.
 *                               Its address must be aligned to 32 bits.
 *
 *  \param[out] *public_key_code Pointer to a public key code buffer that will hold
 *                               the elliptic curve public key code computed from
 *                               the provided private key (code) input.
 *                               Its address must be aligned to 32 bits.
 *
 *  \returns \ref IID_SUCCESS if successful, otherwise another return code.
 */
iid_return_t bk_compute_public_from_private_key(const bk_ecc_private_key_code_t * const private_key_code,
                                                bk_ecc_public_key_code_t * const        public_key_code);

/*! \brief Import an X9.62 binary elliptic curve public key to internal key code format.
 *
 *  \details This function imports an elliptic curve public key from a provided
 *           X9.62 binary format (compressed or uncompressed) to a corresponding
 *           public key code format. The curve and purpose flags of the public key
 *           (code) are also provided as inputs and stored in the public key code.
 *           Note: the protection mechanisms for storing public keys as public key
 *           codes are similar as for the \ref bk_wrap function, but public key
 *           codes cannot be unwrapped by \ref bk_unwrap. The underlying internal
 *           keys used by \ref bk_import_public_key for protecting public key codes
 *           are also different as for key codes generated by \ref bk_wrap. If
 *           needed, the function \ref bk_export_public_key can be used to retrieve
 *           the public key value contained in a public key code.
 *
 *  \param[in] curve Specifies the named elliptic curve on which the imported
 *                   public key is defined. It must be a valid curve type of the
 *                   \ref bk_ecc_curve_t enumeration.
 *
 *  \param[in] purpose_flags Flag which specifies the usage purpose of the public key.
 *                           It must be a valid flag of the \ref bk_ecc_key_purpose_t
 *                           enumeration.
 *
 *  \param[in] *public_key Pointer to a buffer that holds the public key to be imported.
 *                         The expected input is in X9.62 uncompressed binary format.
 *                         The expected size in bytes is determined by the specified
 *                         \ref curve.
 *
 *  \param[out] *public_key_code Pointer to a public key code buffer that will hold
 *                               the imported elliptic curve public key code.
 *                               Its address must be aligned to 32 bits.
 *
 *  \returns \ref IID_SUCCESS if successful, otherwise another return code.
 */
iid_return_t bk_import_public_key(const bk_ecc_curve_t             curve,
                                  const bk_ecc_key_purpose_t       purpose_flags,
                                  const uint8_t * const            public_key,
                                  bk_ecc_public_key_code_t * const public_key_code);

/*! \brief Export an elliptic curve public key from internal key code format to
 *         an X9.62 binary elliptic curve public key format.
 *
 *  \details This function exports a public key from BroadKey's public key code
 *           format to an X9.62 binary elliptic curve public key format, in
 *           uncompressed or compressed representation.
 *           The curve on which the public key is defined, as well as the purpose
 *           flags stored alongside the key in public key code, are returned as well.
 *
 *  \param[in] use_point_compression This flag is present for future use compatibility,
 *                                   but is not used for this product version of BroadKey.
 *                                   For this product version, this value has to
 *                                   be set to False (no point compression). Any
 *                                   other values will result in the return code
 *                                   \ref IID_INVALID_PARAMETERS.
 *
 *  \param[in] *public_key_code Pointer to a public key code buffer that holds
 *                              the elliptic curve public key code to be exported.
 *                              Its address must be aligned to 32 bits.
 *
 *  \param[out] *public_key Pointer to a buffer that will hold the exported public key.
 *                          The output is in X9.62 binary format.
 *                          The size in bytes is determined by the used curve.
 *
 *  \param[out] *curve Pointer to a buffer that will hold the curve on which the
 *                     exported public key is defined.
 *                     The value will be a curve of the \ref bk_ecc_curve_t enumeration.
 *
 *  \param[out] *purpose_flags Pointer to a buffer that will hold the purpose flags
 *                             of the exported public key.
 *                             The value will be a flag of the \ref bk_ecc_key_purpose_t
 *                             enumeration.
 *
 *  \returns \ref IID_SUCCESS if successful, otherwise another return code.
 */
iid_return_t bk_export_public_key(const bool                             use_point_compression,
                                  const bk_ecc_public_key_code_t * const public_key_code,
                                  uint8_t * const                        public_key,
                                  bk_ecc_curve_t * const                 curve,
                                  bk_ecc_key_purpose_t * const           purpose_flags);

/*! \brief Sign a message using ECDSA.
 *
 *  \details This function signs a message or a hash of message using ECDSA with
 *           an elliptic curve private key in the internal private key code format.
 *           Signing can be done with either a random seed or a deterministically
 *           derived seed as indicated by the calling application.
 *
 *  \param[in] *private_key_code Pointer to a private key code buffer that holds
 *                               the elliptic curve private key code to be used
 *                               for signing, and as was created by \ref bk_create_private_key.
 *                               Its address must be aligned to 32 bits.
 *                               Note: a private key code used for signing shall
 *                               have been created with purpose flags allowing
 *                               its use for signing.
 *
 *  \param[in] deterministic_signature Value which specifies if either deterministic
 *                                     or non-deterministic signing will be used.
 *                                     If this value equals False, message will
 *                                     be signed using the standard ECDSA non-deterministic
 *                                     algorithm. Otherwise, the message will be
 *                                     signed using the deterministic algorithm.
 *
 *  \param[in] *message Pointer to a buffer that holds the message or the message
 *                      hash that will be signed.
 *
 *  \param[in] message_length Value which specifies the length in bytes of the \ref message
 *                            buffer. If \ref message_is_hash True (i.e. the provided
 *                            message is actually a message hash), the length must
 *                            be equal to the length in bytes of the used private key,
 *                            as determined by the used curve.
 *                            Otherwise (i.e. the provided message is a raw message
 *                            buffer), the length in bytes must be equal to the
 *                            raw message length. In this case, \ref message_length
 *                            could also be zero in which case an empty message
 *                            will be signed.
 *
 *  \param[in] message_is_hash Value which specifies if the provided \ref message
 *                             buffer contains an already hashed message, or a raw
 *                             message buffer. If this value equals False,
 *                             \ref bk_ecdsa_sign will treat the \ref message buffer
 *                             as a raw message, and will be hash it first using
 *                             SHA-256 and the trailing bytes will be truncated
 *                             to equal the length of the used elliptic curve
 *                             private key before signing the resulting hash.
 *                             Otherwise, \ref bk_ecdsa_sign will treat the message
 *                             buffer as an already hashed message, and it will
 *                             be signed directly.
 *
 *  \param[out] *signature Pointer to buffer that will hold the computed ECDSA signature.
 *                         The size in bytes depends on the used curve, as
 *                         contained in the private key code.
 *
 *  \param[in,out] *signature_length Pointer to a buffer that will contain the size
 *                                   in bytes of the signature.
 *                                   On the input, a pointer to the size of the
 *                                   allocated buffer in order to check for overflow.
 *                                   If the size provided by the input is smaller then
 *                                   the required size, the function returns
 *                                   \ref IID_INVALID_PARAMETERS and sets the value of the
 *                                   variable to the required size. If the size exceeds
 *                                   the required size, the value of the variable is set
 *                                   to the required size as well.
 *
 *  \returns \ref IID_SUCCESS if successful, otherwise another return code.
 */
iid_return_t bk_ecdsa_sign(const bk_ecc_private_key_code_t * const private_key_code,
                           const bool                              deterministic_signature,
                           const uint8_t * const                   message,
                           const uint32_t                          message_length,
                           const bool                              message_is_hash,
                           uint8_t * const                         signature,
                           uint16_t * const                        signature_length);

/*! \brief Verify a message signed with ECDSA.
 *
 *  \details This function verifies the ECDSA signature of a message or a hash
 *           of message with an elliptic curve public key in the internal public
 *           key code format.
 *
 *  \param[in] *public_key_code Pointer to a public key code buffer that holds
 *                              the elliptic curve public key code to be used for
 *                              signature verification.
 *                              Its address must be aligned to 32 bits.
 *                              Note: a public key code used for signature verification
 *                              shall have been computed or imported with purpose
 *                              flags allowing its use for signing.
 *
 *  \param[in] *message Pointer to a buffer that holds the message or the message
 *                      hash on which a signature will be verified.
 *
 *  \param[in] message_length Value which specifies the length in bytes of the
 *                            \ref message buffer. If \ref message_is_hash is True
 *                            (i.e. the provided \ref message is actually a message
 *                            hash), the length must be equal to the length in bytes
 *                            of the used private key, as determined by the used
 *                            curve. Otherwise (i.e. the provided \ref message is
 *                            a raw message buffer), the length in bytes must
 *                            be equal to the raw message length. In this case,
 *                            \ref message_length could also be zero in which case
 *                            an empty message will be signed.
 *
 *  \param[in] message_is_hash Value which specifies if the provided \ref message
 *                             buffer contains an already hashed message, or a
 *                             raw message buffer. If this value equals False,
 *                             \ref bk_ecdsa_verify will treat the \ref message buffer
 *                             as a raw message, and will be hash it first using
 *                             SHA-256 and the trailing bytes will be truncated to
 *                             equal the length of the used elliptic curve private
 *                             key before verifying the signature on the resulting
 *                             hash. Otherwise, \ref bk_ecdsa_verify will treat
 *                             the \ref message buffer as an already hashed message,
 *                             and it will be verified directly.
 *
 *  \param[in] *signature Pointer to a buffer that holds the to-be-verified ECDSA
 *                        signature.
 *
 *  \param[in] signature_length The length in bytes of \ref signature.
 *                              This value depends on the used curve.
 *
 *
 *  \returns \ref IID_SUCCESS if the signature has been verified correctly, otherwise another return code.
 */
iid_return_t bk_ecdsa_verify(const bk_ecc_public_key_code_t * const public_key_code,
                             const uint8_t * const                  message,
                             const uint32_t                         message_length,
                             const bool                             message_is_hash,
                             const uint8_t * const                  signature,
                             const uint16_t                         signature_length);

/*! \brief Compute an ECDH shared secret.
 *
 *  \details This function computes a shared secret value using the ECDH algorithm
 *           on the provided private and public key (codes). The returned shared
 *           secret comprises the X-coordinate of the mutual curve point computed
 *           with the elliptic curve Diffie-Hellman method.
 *
 *  \param[in] *private_key_code Pointer to a private key code buffer that holds
 *                               the elliptic curve private key code to be used
 *                               for computing the shared secret, and as was
 *                               created by \ref bk_create_private_key.
 *                               Its address must be aligned to 32 bits.
 *                               Note: a private key code used for shared secret
 *                               computation shall have been created with purpose
 *                               flags allowing its use for ECDH.
 *
 *  \param[in] *public_key_code Pointer to a public key code buffer that holds
 *                              the elliptic curve public key code to be used for
 *                              computing the shared secret.
 *                              Its address must be aligned to 32 bits.
 *                              Note: a public key code used for shared secret
 *                              computation shall have been computed or imported
 *                              with purpose flags allowing its use for ECDH.
 *                              Note: a public key code used for shared secret
 *                              computation shall contain a public key defined
 *                              over the same curve as the simultaneously provided
 *                              private key code.
 *
 *  \param[out] *shared_secret Pointer to a buffer that will hold the computed
 *                             shared secret. The shared secret will be equal to
 *                             the X-coordinate of the commonly derived point on
 *                             the elliptic curve.
 *                             The size in bytes of the shared secret depends
 *                             on the used curve.
 *
 *  \returns \ref IID_SUCCESS if successful, otherwise another return code.
 */
iid_return_t bk_ecdh_shared_secret(const bk_ecc_private_key_code_t * const private_key_code,
                                   const bk_ecc_public_key_code_t * const  public_key_code,
                                   uint8_t * const                         shared_secret);

/*! \brief Generate a cryptogram holding an encrypted plaintext.
 *
 *  \details This function packs a provided plaintext in a protected cryptogram
 *           format using an elliptic curve hybrid encryption scheme. The
 *           cryptogram format offers protection for confidentiality, integrity,
 *           sender authentication and replay.
 *           A cryptogram is the single message in a one-pass protocol from a
 *           sender to a receiver. The cryptogram generation is based simultaneously
 *           on the sender's private key and the receiver's public key. Both
 *           private and public key are provided as key codes which have to be
 *           defined over the same elliptic curve, and both keycodes must have
 *           their purpose flags set to allow the keys being used for encryption.
 *
 *  \param[in] *receiver_public_key_code Pointer to a public key code buffer that
 *                                       holds the elliptic curve public key code
 *                                       of the receiver to whom the generated
 *                                       cryptogram will be sent.
 *                                       Its address must be aligned to 32 bits.
 *                                       Note: in order to have secure receiver
 *                                       authentication (i.e. assurance to the
 *                                       sender that only the intended receiver
 *                                       will be able to unpack the cryptogram),
 *                                       the public key contained in
 *                                       \ref receiver_public_key_code shall have
 *                                       been verified in an independent manner
 *                                       (e.g. through certificate validation),
 *                                       or it shall come from an independent
 *                                       trusted source.
 *                                       Note: a public key code used for cryptogram
 *                                       generation shall have been computed or
 *                                       imported with purpose flags allowing its
 *                                       use for encryption.
 *
 *  \param[in] *sender_private_key_code Pointer to a private key code buffer that
 *                                      holds the elliptic curve private key code
 *                                      of the sender whom will send the generated
 *                                      cryptogram.
 *                                      Its address must be aligned to 32 bits.
 *                                      Note: a private key code used for cryptogram
 *                                      generation shall have been created with
 *                                      purpose flags allowing its use for encryption.
 *                                      Note: a private key code used for cryptogram
 *                                      generation shall contain a private key
 *                                      defined over the same curve as the
 *                                      simultaneously provided public key code.
 *
 *  \param[in] cryptogram_type Flag which specifies the cryptogram type to be generated.
 *                             It must be a valid flag of the \ref bk_ecc_cryptogram_type_t
 *                             enumeration.
 *
 *  \param[in,out] *counter64 Pointer to a buffer that holds the current 64-bit
 *                            monotonic counter used for cryptogram replay
 *                            protection, and will hold the new counter value
 *                            after successful function completion.
 *                            The size in bytes of the buffer is 8.
 *                            Note: a separate counter buffer shall be used
 *                            for each distinct sender-receiver key pair. The
 *                            calling application needs to retrieve this buffer
 *                            from persistent storage before each call to
 *                            \ref bk_generate_cryptogram, and store back its
 *                            updated value in persistent storage after the
 *                            function completes successfully (return code is
 *                            \ref IID_SUCCESS). Upon first use of a counter buffer
 *                            for a sender-receiver pair, the counter buffer needs
 *                            to be initialized to all-zero bytes, after the
 *                            initial validation of the receiver's public key.
 *
 *  \param[in] *plaintext Pointer to a buffer that holds the plaintext which will
 *                        be encrypted in the cryptogram.
 *                        Its address must be aligned to 32 bits.
 *
 *  \param[in] plaintext_length Value which specifies the length in bytes of \ref plaintext.
 *                              Its value must be positive (> 0) and a multiple of 4.
 *
 *  \param[out] *cryptogram Pointer to a buffer that will hold the generated cryptogram.
 *                          Its address must be aligned to 32 bits.
 *                          The size in bytes depends on the used curve, as
 *                          contained in the private key code, on the specified
 *                          cryptogram_type, and on the length of the provided
 *                          plaintext.
 *
 *  \param[in,out] *cryptogram_length Pointer to a buffer that will hold the size in
 *                                    bytes of the buffer containing the cryptogram.
 *                                    On the input, a pointer to the size of the
 *                                    allocated buffer in order to check for overflow.
 *                                    If the size provided by the input is smaller then
 *                                    the required size, the function returns
 *                                    \ref IID_INVALID_PARAMETERS and sets the value of the
 *                                    variable to the required size. If the size exceeds
 *                                    the required size, the value of the variable is set
 *                                    to the required size as well.
 *
 *  \returns \ref IID_SUCCESS if successful, otherwise another return code.
 */
iid_return_t bk_generate_cryptogram(const bk_ecc_public_key_code_t * const  receiver_public_key_code,
                                    const bk_ecc_private_key_code_t * const sender_private_key_code,
                                    const bk_ecc_cryptogram_type_t          cryptogram_type,
                                    uint8_t * const                         counter64,
                                    const uint8_t * const                   plaintext,
                                    const uint32_t                          plaintext_length,
                                    uint8_t * const                         cryptogram,
                                    uint32_t * const                        cryptogram_length);

/*! \brief Process a received cryptogram to retrieve the contained plaintext.
 *
 *  \details This function processes a received cryptogram in a protected
 *           cryptogram format, to retrieve the contained plaintext, using an
 *           elliptic curve hybrid decryption scheme. The cryptogram format
 *           offers protection for confidentiality, integrity, sender authentication
 *           and replay.
 *           A cryptogram is the single message in a one-pass protocol from a sender
 *           to a receiver. The cryptogram processing is based simultaneously on
 *           the receiver's private key and the sender's public key. Both private
 *           and public key are provided as key codes which shall have been defined
 *           over the same elliptic curve, and which shall both have their purpose
 *           flags set to allow their use for encryption.
 *           A received cryptogram can only be correctly processed (decrypted and
 *           authenticated) if the provided receiver private key and sender public
 *           key correspond respectively to the receiver public key and sender
 *           private key used to create the cryptogram, e.g. using \ref bk_generate_cryptogram.
 *
 *  \param[in] *receiver_private_key_code Pointer to a private key code buffer that
 *                                        holds the elliptic curve private key code
 *                                        of the receiver by whom the cryptogram
 *                                        is processed.
 *                                        Its address must be aligned to 32 bits.
 *                                        Note: a private key code used for cryptogram
 *                                        processing shall have been created with
 *                                        purpose flags allowing its use for encryption.
 *
 *  \param[in] *sender_public_key_code Pointer to a public key code buffer that
 *                                     holds the elliptic curve public key code
 *                                     of the sender from whom the to-be-processed
 *                                     cryptogram was received.
 *                                     Its address must be aligned to 32 bits.
 *                                     Note: in order to have secure sender
 *                                     authentication (i.e. assurance to the
 *                                     receiver that the cryptogram comes from
 *                                     the expected sender), the public key contained
 *                                     in \ref sender_public_key_code shall have
 *                                     been verified in an independent manner
 *                                     (e.g. through certificate certification),
 *                                     or it shall come from an independent trusted
 *                                     source.
 *                                     Note: a public key code used for cryptogram
 *                                     processing shall have been computed or
 *                                     imported with purpose flags allowing its
 *                                     use for encryption.
 *                                     Note: a public key code used for cryptogram
 *                                     processing shall contain a public key defined
 *                                     over the same curve as the simultaneously
 *                                     provided private key code.
 *
 *  \param[out] *cryptogram_type Pointer to a buffer that will hold the cryptogram
 *                               type which was used to generate the cryptogram.
 *                               It will contain a valid flag of the \ref bk_ecc_cryptogram_type_t
 *                               enumeration.
 *
 *  \param[in,out] *counter64 Pointer to a buffer that holds a 64-bit monotonic
 *                            counter used for cryptogram replay protection.
 *                            The size in bytes of the buffer is 8.
 *                            Note: a separate counter buffer shall be used for
 *                            each distinct receiver-sender key pair. The calling
 *                            application needs to retrieve this array from persistent
 *                            storage before each call to bk_process_cryptogram,
 *                            and store back its updated value in persistent storage
 *                            after the function completes successfully (return code
 *                            is \ref IID_SUCCESS). Upon first use of a counter
 *                            array for a receiver-sender pair, the counter array
 *                            needs to be initialized to all-zero bytes, after the
 *                            initial validation of the sender's public key.
 *                            Note: \ref bk_process_cryptogram will only be able
 *                            to successfully process cryptograms which have been
 *                            generated with a corresponding counter value which
 *                            is strictly larger than the integer value provided
 *                            in \ref counter64. This prevents replay of old
 *                            cryptograms, but also obstructs the ability to receive
 *                            multiple consecutive cryptograms out of order.
 *
 *  \param[in] *cryptogram Pointer to a buffer that holds the full cryptogram to
 *                         be processed.
 *                         Its address must be aligned to 32 bits.
 *
 *  \param[in] cryptogram_length Value which specifies the length in bytes of \ref cryptogram.
 *
 *  \param[out] *plaintext Pointer to a buffer that will hold the decrypted plaintext.
 *                         Its address must be aligned to 32 bits.
 *                         The length in bytes of the plaintext depends on the
 *                         cryptogram length, the used elliptic curve, and the used
 *                         cryptogram type.
 *
 *  \param[in,out] *plaintext_length Pointer to a buffer that will hold the size
 *                                   in bytes of the buffer containing the plaintext.
 *                                   On the input, a pointer to the size of the
 *                                   allocated buffer, in order to check for overflow.
 *                                   If the size provided by the input is smaller then
 *                                   the required size, the function returns
 *                                   \ref IID_INVALID_PARAMETERS and sets the value of the
 *                                   variable to the required size. If the size exceeds
 *                                   the required size, the value of the variable is set
 *                                   to the required size as well.
 *
 *  \returns \ref IID_SUCCESS if successful, otherwise another return code.
 */
iid_return_t bk_process_cryptogram(const bk_ecc_private_key_code_t * const receiver_private_key_code,
                                   const bk_ecc_public_key_code_t * const  sender_public_key_code,
                                   bk_ecc_cryptogram_type_t * const        cryptogram_type,
                                   uint8_t * const                         counter64,
                                   const uint8_t * const                   cryptogram,
                                   const uint32_t                          cryptogram_length,
                                   uint8_t * const                         plaintext,
                                   uint32_t * const                        plaintext_length);

/*! \brief Export the public key embedded in a cryptogram.
 *
 *  \details This function exports the public key embedded in a cryptogram to an
 *           X9.62 binary elliptic curve public key format, in uncompressed or
 *           compressed representation.
 *
 *  \param[in] use_point_compression This flag is present for future use compatibility,
 *                                   but is not used for this product version of BroadKey.
 *                                   For this product version, this value has to
 *                                   be set to False (no point compression). Any
 *                                   other values will result in the return code
 *                                   \ref IID_INVALID_PARAMETERS.
 *
 *  \param[in] curve Specifies the named elliptic curve on which the \ref cryptogram
 *                   is defined. It must be a valid curve type of the
 *                   \ref bk_ecc_curve_t enumeration.
 *
 *  \param[in] *cryptogram Pointer to a buffer that holds the full cryptogram.
 *                         Its address must be aligned to 32 bits.
 *
 *  \param[in] cryptogram_length Value which specifies the length in bytes of \ref cryptogram.
 *
 *  \param[out] *public_key Pointer to a buffer that will hold the exported public key.
 *                          The output is in X9.62 binary format.
 *                          The size in bytes is determined by the used curve.
 *
 *  \returns \ref IID_SUCCESS if successful, otherwise another return code.
 */
iid_return_t bk_get_public_key_from_cryptogram(const bool            use_point_compression,
                                               const bk_ecc_curve_t  curve,
                                               const uint8_t * const cryptogram,
                                               const uint32_t        cryptogram_length,
                                               uint8_t * const       public_key);



#ifdef __cplusplus
}
#endif

#endif /* __IID_BROADKEY__H__ */
